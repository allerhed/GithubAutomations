name: Inbox ‚Üí AI Analysis & Issue Creation

on:
  push:
    paths: ["inbox/**"]
  issues:
    types: [opened]
  pull_request:
    types: [opened]

permissions:
  contents: write
  issues: write
  pull-requests: write
  models: read

jobs:
  intake:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Find files newly ADDED under inbox/ in this push
      - name: List newly-added inbox files
        id: diff
        run: |
          git fetch --depth=1 origin "${{ github.event.before }}" || true
          git diff --name-only --diff-filter=A "${{ github.event.before }}" "${{ github.sha }}" -- 'inbox/**' > added.txt
          echo "count=$(wc -l < added.txt)" >> "$GITHUB_OUTPUT"
          echo "files<<EOF" >> "$GITHUB_OUTPUT"
          cat added.txt >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      # Install gh-models extension
      - name: Install gh-models extension
        if: steps.diff.outputs.count != '0'
        run: gh extension install https://github.com/github/gh-models
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Analyze inbox files with GitHub Models (GPT-4o) and create issues
      - name: Analyze inbox files and create issues
        if: steps.diff.outputs.count != '0'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          while IFS= read -r f; do
            [ -z "$f" ] && continue
            echo "ü§ñ Analyzing with GitHub Models: $f"

            # Read file content
            if [ "$(wc -c < "$f")" -gt 100000 ]; then
              head -c 100000 "$f" > /tmp/file_content.txt
              echo -e "\n\n[NOTE: truncated for length]" >> /tmp/file_content.txt
            else
              cp "$f" /tmp/file_content.txt
            fi

            # Create system prompt
            SYSTEM_PROMPT="You are an expert software project manager analyzing intake documents. Your task is to parse the document and extract actionable items (features, bugs, documentation tasks, etc.). For each item found, output a JSON object with: title, body (markdown with summary, acceptance criteria as checklist, context), labels (array of strings like 'bug', 'enhancement', 'documentation', 'backend', 'frontend', etc.). Output ONLY a valid JSON array of issue objects, nothing else. Example: [{\"title\":\"Feature: Add rate limiting\",\"body\":\"## Summary\\n...\\n## Acceptance Criteria\\n- [ ] ...\",\"labels\":[\"enhancement\",\"backend\"]}]"

            USER_PROMPT="Analyze this intake document and extract all actionable items as separate GitHub issues:"

            # Call GitHub Models using gh-models extension
            set +e  # Temporarily disable exit on error
            ISSUES_JSON=$(cat /tmp/file_content.txt | gh models run gpt-4o --system "$SYSTEM_PROMPT" "$USER_PROMPT" 2>&1)
            EXIT_CODE=$?
            set -e  # Re-enable exit on error
            
            if [ $EXIT_CODE -ne 0 ]; then
              echo "‚ùå GitHub Models API call failed with exit code $EXIT_CODE: $ISSUES_JSON"
              continue
            fi
            
            if [ -z "$ISSUES_JSON" ] || [ "$ISSUES_JSON" = "null" ]; then
              echo "‚ö†Ô∏è No valid response from GitHub Models for $f"
              continue
            fi

            # Parse and create issues
            echo "$ISSUES_JSON" | jq -c '.[]' 2>/dev/null | while read -r issue; do
              TITLE=$(echo "$issue" | jq -r '.title')
              BODY=$(echo "$issue" | jq -r '.body')
              LABELS=$(echo "$issue" | jq -r '.labels | join(",")')
              
              if [ -z "$TITLE" ] || [ "$TITLE" = "null" ]; then
                echo "‚ö†Ô∏è Skipping invalid issue"
                continue
              fi

              # Add reference to source file and create issue body
              {
                echo "$BODY"
                echo ""
                echo "___"
                echo ""
                echo "*Generated from: \`$f\`*"
              } > /tmp/issue_body.md

              echo "üìù Creating issue: $TITLE"
              
              # Create the issue
              gh issue create \
                --title "$TITLE" \
                --body-file /tmp/issue_body.md \
                --label "$LABELS" || echo "‚ö†Ô∏è Failed to create issue: $TITLE"
            done

            echo "‚úÖ Completed analysis of $f"
          done < added.txt

  # Belt-and-suspenders: auto-assign Copilot to any newly opened Issue
  auto_assign_issue:
    if: github.event_name == 'issues' && github.event.action == 'opened'
    runs-on: ubuntu-latest
    steps:
      - name: Assign copilot-swe-agent to Issue (if available)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Try to assign; if agent isn't available, this will no-op
          gh issue edit "${{ github.event.issue.number }}" --add-assignee copilot-swe-agent || true

  # Belt-and-suspenders: auto-assign Copilot to any newly opened PR
  auto_assign_pr:
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    runs-on: ubuntu-latest
    steps:
      - name: Assign copilot-swe-agent to PR (if available)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # PRs are issues under the hood
          gh issue edit "${{ github.event.pull_request.number }}" --add-assignee copilot-swe-agent || true
